---
layout: post
title: 'Chapter 10'
date: 2020-06-21
author: Xiao Guo
cover: '/assets/img/MountAl.jpg'
tags: CS3114 week4 data-structures
---

> Hashing

### Definition and background
Hashing is a wide-used system for access and store records in a database. It's usually based on the key-value pair feature. This feature makes hashing so unique that the search, insert, and delete operation will only need to look at one or two records. To calculate the hash value of one record, we need a unique function to process the calculation, which is called the hashing function.

### Hash Function Principles and sample hashing function
The reason why we want to have these principles are the possibilities of collision. Detailed: [openDSA](https://canvas.vt.edu/courses/111334/assignments/883573?module_item_id=901488)

1. Simple mod function: simply mod the int to an array of 16
2. Binning:
3. The Mid-Square method
4. A simple hash function for Strings: from  [openDSA](https://canvas.vt.edu/courses/111334/assignments/883573?module_item_id=901488)
```
   int sascii(String x, int M) {
     char ch[];
     ch = x.toCharArray();
     int xlength = x.length();

     int i, sum;
     for (sum=0, i=0; i < x.length(); i++)
       sum += ch[i];
     return sum % M;
   }
```
5. String Folding
```
// Use folding on a string, summed 4 bytes at a time
int sfold(String s, int M) {
  long sum = 0, mul = 1;
  for (int i = 0; i < s.length(); i++) {
    mul = (i % 4 == 0) ? 1 : mul * 256;
    sum += s.charAt(i) * mul;
  }
  return (int)(Math.abs(sum) % M);
}
```

### Open Hashing and Bucket Hashing
Open hashing: Even though the key principle when designing the hashing function is to minimize the collisions, they are still unavoidable in a certain way. In this case, we need a proper handle method for the collision. There are two common way: open hashing(separate chaining) and closed hashing(open addressing). Open hashing means there is a linked list for the same hash value, so the corresponding records who hold the same hash value will be stored in a list by either insertion order, key-value order or frequency order. 

Note: Open hashing is most appropriate when the hash table is kept in the main memory.

Bucket Hashing: The closed hashing keeps all the records in the hash table, which led to the question of a proper method to find another slot for the new record who holds the same hash value. Using the bucket, we can easily solve this problem.

### Collision Resolution
The most frequently used hashing method is closed hashing with no bucketing. The strategy for solving the occupied position is to have a sequence of slots called the probe sequence, generated by some probe function. The insert method is shown below:
[openDSA](https://canvas.vt.edu/courses/111334/assignments/883573?module_item_id=901488)
```
   // Insert e into hash table HT
   void hashInsert(Key k, Elem e) {
     int home;                     // Home position for e
     int pos = home = h(k);        // Init probe sequence
     for (int i=1; EMPTYKEY != (HT[pos]).key(); i++) {
       pos = (home + p(k, i)) % M; // probe
       if (k == HT[pos].key()) {
         println("Duplicates not allowed");
         return;
       }
     }
     HT[pos] = e;
   }
```

The search method is shown below:[openDSA](https://canvas.vt.edu/courses/111334/assignments/883573?module_item_id=901488)
```
   // Search for the record with Key K
   bool hashSearch(Key K, Elem e) {
     int home;              // Home position for K
     int pos = home = h(K); // Initial position is the home slot
     for (int i = 1;
          (K != (HT[pos]).key()) && (EMPTYKEY != (HT[pos]).key());
          i++)
       pos = (home + p(K, i)) % M; // Next on probe sequence
     if (K == (HT[pos]).key()) {   // Found it
       e = HT[pos];
       return true;
     }
     else return false;            // K not in hash table
   }
```

Note: Both of these two functions assume that there is at least one available slot on the probe sequence. 
Note: For improved Collision Resolution, find explanation on [openDSA](https://canvas.vt.edu/courses/111334/assignments/883573?module_item_id=901488)


### Efficiency Analysis and deletion
For detailed analysis:[openDSA](https://canvas.vt.edu/courses/111334/assignments/883573?module_item_id=901488)

Key Idea:
1. The hashing table is at its max efficiency when the hash table is less than half full. This property requires the developer to design a proper system to prevent the table from being over half-full.
2. The deletion operation can't hinder the later search process. This can be avoided by tombstones.
