---
layout: post
title: 'Chapter 11'
date: 2020-06-20
author: Xiao Guo
cover: '/assets/img/MountAl.jpg'
tags: CS3114 week4 data-structures
---

> Memory Management

### Definition and background
In this chapter, we will be focusing on the memory management techniques regrading handling space requests of a variable size. Normally, we will have a big memory block called the memory pool. When we need certain space to store our value, we will send request to the memory manager which will then return some handles to clarify the memory we can use. Once when we don;t need the space, we can deallocate the memory and leave it for future use. We will talk about this kind of dynamic memory allocation in following section.

### Dynamic Storage Allocation
The key idea for dynamic storage is that when we need to store a data set of size k, then we need at least a memory block of size m where m is larger then k. This leads to two problem: The first one is what should we do when there is no block of size m that satisfy the requirement, which will require a proper garbage collection strategy. The second one is how to manage the memory block when there is too many small block caused by multiple operations.

### Sequential-Fit methods
There are two fundamental ways to deal with executing the freelist. The more straightforward methodology is to store the freelist independently from the memory pool. As it were, a basic connected rundown usage can be utilized, where every hub of the connected rundown contains a pointer to a solitary free square in the memory pool. This is fine if there is space accessible for the connected show itself, separate from the memory pool.
For detailed explanation [openDSA](https://canvas.vt.edu/courses/111334/modules/items/901507)

Approaches:from [openDSA](https://canvas.vt.edu/courses/111334/modules/items/901507)
1. First Fit:move down the free block list until a block that satisfy the requirement is found. Since this approach selects the first block with enough space, it's called First-fit.

2. Circular first-fit: A simple improved variation of the first-fit approach. The circular means we will start from the last position reached in the previous search, instead of always starting from the head. This variation can reduce the number of unnecessary searches.

3. Best Fit: best fit was designed to solve a potential disadvantage of first-fit approach:it may waste the memory block by breaking a big block into smaller ones. To avoid this waste, the best-fit will search the whole list and find the smallest block that satisfy the requirement. However, this search takes time too. Also, there is another problem that the remaining portion of the best-fit block can be so small that are useless for future requests.

4. Worst-fit: In contrary to best-fit, the worst-fit approach always take the largest block. Similar with best-fit, the worst fit also needs to traverse the whole list, or we can order the list by size to reduce cost.

Note: If the sizes of requests varies a lot, the best-fit can be most suitable. However, when the requests are almost equally weighted, the first or worst fit may performs better.

Note: There are other methods for memory allocation:[openDSA](https://canvas.vt.edu/courses/111334/modules/items/901514)

### Failure Policies and Garbage Collection
Sometimes, we will meet a situation that the memory manager doesn't have enough space to satisfy the requirement while the program requires a immediate feedback. So the manager has to return a failure message which may lead to a program error. Some failure policies includes delay the memory request until there is one block satisfy the requirement, or simply allocate more memory for the memory manager. However, when all this are failed, we need to consider the last failure policy called garbage collection. 

Definition: When a memory is unpointed, the memory block is called garbage since we can't access it. Java has a dynamic garbage collector which really helped programmer though with a cost of increased compiling time. In contrary, C language needs programmer to manually deallocate the memory to prevent from getting errors. For detailed introduction of garbage collection algorithm, check[openDSA](https://canvas.vt.edu/courses/111334/modules/items/901516)